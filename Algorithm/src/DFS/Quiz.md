문제
문제명 : 로봇 모으기
 
제한 조건
실행시간 : 50개의 테스트 케이스를 합쳐서 C/C++의 경우 3초, JAVA의 경우 5초, Python 10초
메 모 리 : Heap, Global, Stack 등을 모두 합해 최대 256MB까지 사용 가능 (단, 스택은 최대 1MB까지 사용 가능)
제출 횟수 제한
제한 없음
채점
Accept : Sample_input으로 채점시 정상적으로 제출되었다는 의미
            (단순히 컴파일 에러 등 없다는 의미이며 점수는 공개하지 않음)
Fail : 컴파일, 런타임 에러 등으로 0점
평가
Sample_input은 편의를 위해 제공하며, 실제 채점은 별도의 평가용 input으로 이루어진다.
 

M개의 행과 M개의 열이 있는 격자칸이 있다.
격자의 칸들 중 일부에 N개의 로봇이 있고 그 위치가 (행 번호, 열 번호)의 쌍으로 주어진다.
행 번호와 열 번호는 1부터 M까지이다.
행 번호는 위쪽이 작은 쪽이며, 열 번호는 왼쪽이 작은 쪽이다.
 
모든 로봇들에게 동시에 명령을 주는데, 명령은 U, L, R의 3가지이고, U는 위로, L은 왼쪽으로, R은 오른쪽으로 한 칸씩 이동하라는 것이다.
 
끝에 도달하여 더 이상 갈 수 있는 칸이 없는 경우 로봇은 움직이지 않는다.
또, 한 칸에 여러 개의 로봇이 겹쳐서 들어갈 수 있다.
 
모든 로봇이 한 칸에 모이기 위한 최소 명령 횟수를 구하는 프로그램을 작성하라.
 
예를 들어 격자의 크기가 M=6 인 격자칸에 N=4개의 로봇이 있다
로봇들의 초기 위치가 각각 (2, 3), (3, 2), (1, 4), (4, 5)라고 한다.
첫 명령으로 U를 주면 로봇들의 위치는 (1, 3), (2, 2), (1, 4), (3, 5)가 된다. 세번째 로봇은 움직이지 않았음에 주의하라.
다시 U 명령을 주면 로봇들의 위치는 (1, 3), (1, 2), (1, 4), (2, 5)가 된다.
이후 U, L, L, L, L의 명령을 이어서 주면 로봇이 모두 (1, 1) 위치에 모인다. 이 경우의 답은 7이다.
아래 그림은 위 과정을 보여준다. 로봇은 별 모양으로 표시하였다.


 


 

두 번째 예로 격자의 크기 M=5이고, N=3개의 로봇이 있다고 하자.
로봇들의 초기 위치가 각각 (5, 4), (4, 4), (5, 5)라고 한다.
첫 명령으로 U를 주면 로봇들의 위치는 (4, 4), (3, 4), (4, 5)가 된다.
이후 U, U, U, R의 명령을 이어서 주면 로봇이 모두 (1, 5) 위치에 모인다. 이 경우의 답은 5이다.
 
 


 

[제약사항]
1.     격자의 크기 M은 5 이상 300 이하이다. (5 ≤ M ≤ 300)
2.     로봇의 개수 N은 2 이상 300 이하이다. (2 ≤ N ≤ 300)
3.     로봇들 중에는 시작 위치의 행 번호가 다른 로봇의 쌍이 반드시 존재하고, 열 번호가 다른 로봇의 쌍도 반드시 존재한다.(아래 그림과 같이 모든 로봇의 행 번호가 같거나 열 번호가 같은 경우는 주어지지 않는다는 의미이다.)



 



[입력]
가장 첫 줄에는 테스트 케이스의 총 수가 주어진다.
그 다음 줄부터 각 테스트 케이스가 주어지며, 각 테스트 케이스는 N+1줄로 구성된다. 각 테스트 케이스의 첫 줄에는 M과 N이 주어진다. 다음 N개의 줄에는 각 로봇의 초기 위치에 해당하는 행번호, 열번호의 쌍이 주어진다.
 
[출력]
출력의 각 줄은 ‘#x’로 시작하고, 공백을 한 칸 둔 다음 최소 명령 갯수를 출력한다. 단, x는 테스트 케이스의 번호이다.
 
[입력 예]
2                         // 테스트 케이스의 수
6 4                      // M=6, N = 4, 테스트 케이스 #1
2 3
3 2
1 4
4 5
5 3                     // M=5, N = 3, 테스트 케이스 #2
5 4
4 4
5 5
 
[출력 예]
#1 7
#2 5
2. 욕심쟁이
 

 
